using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;


namespace IRTicker
{
    class CoinbaseClient
    {
        private string ApiKey { get; set; }
        private string UnsignedSignature { get; set; }
        private string PassPhrase { get; set; }

        public async Task<string> GetAccounts(string inAPIKey, string inAPISecret, string inPassPhrase) {

            HttpClient httpClient = new HttpClient();

            ApiKey = inAPIKey;
            UnsignedSignature = inAPISecret;
            PassPhrase = inPassPhrase;

            var httpRequestMessage = BuildHTTPRequest("https://api.exchange.coinbase.com", "/accounts", "", HttpMethod.Get);
            if (null == httpRequestMessage) return "";

            HttpResponseMessage httpResponseMessage;
            try {
                httpResponseMessage = await httpClient.SendAsync(httpRequestMessage).ConfigureAwait(false);
                string res =  await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(false);
                return res;
            }
            catch (Exception ex) {
                Debug.Print(DateTime.Now + " - Caught exception in Coinbase class when doing network things: " + ex.Message);
            }
            return "";
        }

        private HttpRequestMessage BuildHTTPRequest(string apiUri, string requestUri, string contentBody, HttpMethod httpMethod) {

            var requestMessage = new HttpRequestMessage(HttpMethod.Get, new Uri(new Uri(apiUri), requestUri)) {
                Content = contentBody == string.Empty
                    ? null
                    : new StringContent(contentBody, Encoding.UTF8, "application/json")
            };

            double timeStamp = (DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds;  // epoch time

            if (string.IsNullOrEmpty(ApiKey) || string.IsNullOrEmpty(UnsignedSignature) || string.IsNullOrEmpty(PassPhrase)) {
                return null;
            }

            string signedSignature = ComputeSignature(httpMethod, UnsignedSignature, timeStamp, requestUri, contentBody);
            string signedSig2 = GenerateSignature(timeStamp.ToString("F0", CultureInfo.InvariantCulture), httpMethod.ToString().ToUpper(), requestUri, "", UnsignedSignature);

            AddHeaders(requestMessage, signedSignature, timeStamp);  // requestMessage is manipulated by this method

            return requestMessage;
        }


        private void AddHeaders(HttpRequestMessage httpRequestMessage, string signedSignature, double timeStamp) {

            httpRequestMessage.Headers.Add("User-Agent", "IRTicker");

            // CB - ACCESS - KEY The api key as a string.
            // CB - ACCESS - SIGN The base64-encoded signature(see Signing a Message).
            // CB - ACCESS - TIMESTAMP A timestamp for your request.
            // CB - ACCESS - PASSPHRASE The passphrase you specified when creating the API key.
            httpRequestMessage.Headers.Add("CB-ACCESS-KEY", ApiKey);
            httpRequestMessage.Headers.Add("CB-ACCESS-TIMESTAMP", timeStamp.ToString("F0", CultureInfo.InvariantCulture));
            httpRequestMessage.Headers.Add("CB-ACCESS-SIGN", signedSignature);
            httpRequestMessage.Headers.Add("CB-ACCESS-PASSPHRASE", PassPhrase);
        }


        // From Coinbase API docs - https://docs.exchange.coinbase.com/#signing-a-message
        // The CB-ACCESS-SIGN header is generated by creating a sha256 HMAC using the base64-decoded secret key on the prehash 
        // string timestamp + method + requestPath + body (where + represents string concatenation) and base64-encode the output. 
        // The timestamp value is the same as the CB-ACCESS-TIMESTAMP header.
        private string ComputeSignature(
            HttpMethod httpMethod,
            string secret,
            double timestamp,
            string requestUri,
            string contentBody = "") {

            var convertedString = Convert.FromBase64String(secret);
            var prehash = timestamp.ToString("F0", CultureInfo.InvariantCulture) + httpMethod.ToString().ToUpper() + requestUri + contentBody;
            return HashString(prehash, convertedString);
        }

        // ... magic
        private string HashString(string str, byte[] secret) {
            var bytes = Encoding.UTF8.GetBytes(str);
            using (var hmaccsha = new HMACSHA256(secret)) {
                return Convert.ToBase64String(hmaccsha.ComputeHash(bytes));
            }
        }


        static string ByteToHexString(byte[] bytes) {
            char[] c = new char[bytes.Length * 2];
            int b;
            for (int i = 0; i < bytes.Length; i++) {
                b = bytes[i] >> 4;
                c[i * 2] = (char)(87 + b + (((b - 10) >> 31) & -39));
                b = bytes[i] & 0xF;
                c[i * 2 + 1] = (char)(87 + b + (((b - 10) >> 31) & -39));
            }
            return new string(c);
        }

        public static string GenerateSignature(string timestamp, string method, string url, string body, string appSecret) {
            return GetHMACInHex(appSecret, timestamp + method + url + body);
        }

        internal static string GetHMACInHex(string key, string data) {
            var hmacKey = Encoding.UTF8.GetBytes(key);
            var dataBytes = Encoding.UTF8.GetBytes(data);

            using (var hmac = new HMACSHA256(hmacKey)) {
                var sig = hmac.ComputeHash(dataBytes);
                return ByteToHexString(sig);
            }
        }
    }
}
